from slurm_api_cli_proxy.client_args_linker.slurm_api_client_wrapper import SlurmAPIClientWrapper, SbatchResponse, SqueueResponse
import openapi_client

#sbatch related
from openapi_client.models.v0039_job_submission import V0039JobSubmission
from openapi_client.models.v0039_job_submission_response import V0039JobSubmissionResponse
from openapi_client.rest import ApiException

#squeue related
from openapi_client.models.v0039_jobs_response import V0039JobsResponse
from openapi_client.models.v0039_job_info import V0039JobInfo
from openapi_client.models.v0039_job_res import V0039JobRes

import os
import json
import time
import pprint



class V39SlurmAPIClientWrapper(SlurmAPIClientWrapper):

    def sbatch_post_request(self,request:dict,conf:openapi_client.Configuration,slurmrestd_token:str)-> SbatchResponse:     
        #Based on the code snippet included on the documentation generated from the Slurm OpenAPI specification
        configuration = conf
        configuration.api_key['token'] = slurmrestd_token
        with openapi_client.ApiClient(configuration) as api_client:
            # Create an instance of the API class
            
            api_instance = openapi_client.SlurmApi(api_client)

            # Convert the dictionary to a JSON string
            json_req_string = json.dumps(request, indent=2)

            v0039_job_submission_instance = V0039JobSubmission.from_json(json_req_string)
            try:
                # submit the job
                api_response = api_instance.slurm_v0039_submit_job(v0039_job_submission_instance)
                
                response = SbatchResponse(job_id=api_response.job_id,step_id=api_response.step_id)
                
                for err in api_response.errors:
                    #Based on V0039Error type
                    #TODO check if a template may be required
                    response.errors.append(f"Error no:{err.error_number}:{err.error}. Source:{err.source}. Description:{err.description}")
                
                return response

            except Exception as e:                
                response = SbatchResponse(job_id=None,step_id=None)
                response.errors.append(f"SLURM_PROXY_ERROR: {e}")
                return response

    def squeue_get_request(self,cli_arguments:dict,conf:openapi_client.Configuration,slurmrestd_token:str)-> SqueueResponse:    
        #Based on the code snippet included on the documentation generated from the Slurm OpenAPI specification
        configuration = conf
        configuration.api_key['token'] = slurmrestd_token
    
    
        with openapi_client.ApiClient(configuration) as api_client:
            # Create an instance of the API class
            api_instance = openapi_client.SlurmApi(api_client)
            #update_time = 56 # int | Filter if changed since update_time. Use of this parameter can result in faster replies. (optional)

            try:
                # get list of jobs
                api_response = api_instance.slurm_v0039_get_jobs()

                output = V39SlurmAPIClientWrapper.process_squeue_output(cli_arguments=cli_arguments,jobs=api_response.jobs)

                return SqueueResponse(output,errors=api_response.errors,warnings=api_response.warnings)
        
            except Exception as e:                
                response = SqueueResponse("",errors=[f"[SLURM_PROXY_ERROR]: {e}"])
                return response


    @staticmethod
    def process_squeue_output(cli_arguments:dict,jobs:list[V0039JobInfo])->str: 
        """
        Processes the details returned by the GET request to /jobs so that
        they mimic the output generated by squeue command, according to the
        arguments given (cli_arguments)
        
        Args:
            cli_arguments (dict): The arguments given when running the proxy command
            jobs (list[V0039JobInfo]): A list of job information objects.
        Returns:
            str: A formatted string representing the job queue.
        """
        
        slurm_statuses = {
            "BOOT_FAIL": "BF",
            "CANCELLED": "CA",
            "COMPLETED": "CD",
            "CONFIGURING": "CF",
            "COMPLETING": "CG",
            "DEADLINE": "DL",
            "FAILED": "F",
            "NODE_FAIL": "NF",
            "OUT_OF_MEMORY": "OOM",
            "PENDING": "PD",
            "PREEMPTED": "PR",
            "RUNNING": "R",
            "RESV_DEL_HOLD": "RD",
            "REQUEUE_FED": "RF",
            "REQUEUE_HOLD": "RH",
            "REQUEUED": "RQ",
            "RESIZING": "RS",
            "REVOKED": "RV",
            "SIGNALING": "SI",
            "SPECIAL_EXIT": "SE",
            "STAGE_OUT": "SO",
            "STOPPED": "ST",
            "SUSPENDED": "S",
            "TIMEOUT": "TO"
        }
                
        output = "JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)\n"

        timestamp = int(time.time())

        #e.g.: V0039JobRes(nodes='slurm-worker', allocated_cores=0, allocated_cpus=0, allocated_hosts=1, allocated_nodes=[{'sockets': {'0': {'cores': {'0': 'allocated'}}}, 'nodename': 'slurm-worker', 'cpus_used': 0, 'memory_used': 0, 'memory_allocated': 1}])


        for job in jobs:            
            job_resources:V0039JobRes = job.job_resources      
            elapsed_time = str(seconds_to_hhmm(timestamp-job.start_time)) if job.job_state == "RUNNING" else "00:00"
            output += f"{str(job.job_id)[:5]:5} {str(job.partition)[:9]:9} {str(job.name)[:8]:8} {job.user_name[:8]:8} {slurm_statuses[job.job_state][:8]:8} {elapsed_time[:5]:5} {str(job_resources.allocated_hosts)[:5]:5} {job_resources.nodes}\n"

        return output
    
        
def seconds_to_hhmm(seconds):
    """
    Convert seconds to HH:MM format.
    
    Args:
        seconds (int): Number of seconds to convert
        
    Returns:
        str: Time in HH:MM format
        
    """
    minutes = seconds // 60
    remaining_seconds = seconds % 60
    return f"{minutes:02d}:{remaining_seconds:02d}"